"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OptimizedRule = exports.Rule = void 0;
const nimma_1 = require("nimma");
const severity_1 = require("./rulesets/severity");
const utils_1 = require("./utils");
class Rule {
    constructor(name, rule) {
        var _a, _b;
        this.name = name;
        this.description = (_a = rule.description) !== null && _a !== void 0 ? _a : null;
        this.message = (_b = rule.message) !== null && _b !== void 0 ? _b : null;
        this.severity = rule.severity === void 0 ? severity_1.DEFAULT_SEVERITY_LEVEL : severity_1.getDiagnosticSeverity(rule.severity);
        this.resolved = rule.resolved !== false;
        this.formats = rule.formats;
        this.then = Array.isArray(rule.then) ? rule.then : [rule.then];
        this.given = Array.isArray(rule.given) ? rule.given : [rule.given];
    }
    get enabled() {
        return this.severity !== -1;
    }
    matchesFormat(formats) {
        if (this.formats === void 0) {
            return true;
        }
        return Array.isArray(formats) && utils_1.hasIntersectingElement(this.formats, formats);
    }
}
exports.Rule = Rule;
function stub() {
}
class OptimizedRule extends Rule {
    constructor(name, rule) {
        super(name, rule);
        this.expressions = this.given.map(given => {
            const expr = new nimma_1.JSONPathExpression(given, stub, stub);
            if (expr.matches === null) {
                throw new Error(`Rule "${name}": cannot optimize ${given}`);
            }
            return expr;
        });
    }
    hookup(cb) {
        for (const expr of this.expressions) {
            expr.onMatch = (value, path) => {
                cb(this, {
                    path,
                    value,
                });
            };
        }
    }
}
exports.OptimizedRule = OptimizedRule;
//# sourceMappingURL=rule.js.map
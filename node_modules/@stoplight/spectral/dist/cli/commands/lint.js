"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.severeEnoughToFail = void 0;
const tslib_1 = require("tslib");
const lodash_1 = require("lodash");
const yargs_1 = require("yargs");
const severity_1 = require("../../rulesets/severity");
const config_1 = require("../../types/config");
const linter_1 = require("../services/linter");
const output_1 = require("../services/output");
const toArray = (args) => (Array.isArray(args) ? args : [args]);
const formatOptions = Object.values(config_1.OutputFormat);
const lintCommand = {
    describe: 'lint JSON/YAML documents from files or URLs',
    command: 'lint [documents..]',
    builder: yargs => yargs
        .strict()
        .positional('documents', {
        description: 'Location of JSON/YAML documents. Can be either a file, a glob or fetchable resource(s) on the web.',
        type: 'string',
        coerce(values) {
            if (values.length > 0) {
                return values;
            }
            if (process.stdin.isTTY) {
                return [];
            }
            return [process.stdin.fd];
        },
    })
        .fail(() => {
        yargs_1.showHelp();
    })
        .check((argv) => {
        if (argv.format !== void 0 && !formatOptions.includes(String(argv.format))) {
            return false;
        }
        if (!Array.isArray(argv.documents) || argv.documents.length === 0) {
            return false;
        }
        return true;
    })
        .options({
        encoding: {
            alias: 'e',
            description: 'text encoding to use',
            type: 'string',
            default: 'utf8',
        },
        format: {
            alias: 'f',
            description: 'formatter to use for outputting results',
            choices: formatOptions,
            default: config_1.OutputFormat.STYLISH,
            type: 'string',
        },
        output: {
            alias: 'o',
            description: 'output to a file instead of stdout',
            type: 'string',
        },
        resolver: {
            description: 'path to custom json-ref-resolver instance',
            type: 'string',
        },
        ruleset: {
            alias: 'r',
            description: 'path/URL to a ruleset file',
            type: 'string',
            coerce: toArray,
        },
        'skip-rule': {
            alias: 's',
            description: 'ignore certain rules if they are causing trouble',
            type: 'string',
            coerce: toArray,
        },
        'fail-severity': {
            alias: 'F',
            description: 'results of this level or above will trigger a failure exit code',
            choices: ['error', 'warn', 'info', 'hint'],
            default: 'error',
            type: 'string',
        },
        'display-only-failures': {
            alias: 'D',
            description: 'only output results equal to or greater than --fail-severity',
            type: 'boolean',
            default: false,
        },
        'ignore-unknown-format': {
            description: 'do not warn about unmatched formats',
            type: 'boolean',
            default: false,
        },
        'show-unmatched-globs': {
            description: 'show unmatched glob patterns',
            type: 'boolean',
            default: false,
            deprecated: 'use --fail-on-unmatched-globs',
        },
        'fail-on-unmatched-globs': {
            description: 'fail on unmatched glob patterns',
            type: 'boolean',
            default: false,
        },
        verbose: {
            alias: 'v',
            description: 'increase verbosity',
            type: 'boolean',
        },
        quiet: {
            alias: 'q',
            description: 'no logging - output only',
            type: 'boolean',
        },
    }),
    handler: args => {
        const _a = args, { documents, failSeverity, displayOnlyFailures, ruleset, format, output, encoding, ignoreUnknownFormat, showUnmatchedGlobs, failOnUnmatchedGlobs } = _a, config = tslib_1.__rest(_a, ["documents", "failSeverity", "displayOnlyFailures", "ruleset", "format", "output", "encoding", "ignoreUnknownFormat", "showUnmatchedGlobs", "failOnUnmatchedGlobs"]);
        return linter_1.lint(documents, Object.assign({ format,
            output,
            encoding,
            ignoreUnknownFormat,
            failOnUnmatchedGlobs,
            showUnmatchedGlobs,
            ruleset }, lodash_1.pick(config, ['skipRule', 'verbose', 'quiet', 'resolver'])))
            .then(results => {
            if (displayOnlyFailures) {
                return filterResultsBySeverity(results, failSeverity);
            }
            return results;
        })
            .then(results => {
            if (results.length > 0) {
                process.exitCode = exports.severeEnoughToFail(results, failSeverity) ? 1 : 0;
            }
            else if (config.quiet !== true) {
                console.log(`No results with a severity of '${failSeverity}' or higher found!`);
            }
            const formattedOutput = output_1.formatOutput(results, format, { failSeverity: severity_1.getDiagnosticSeverity(failSeverity) });
            return output_1.writeOutput(formattedOutput, output);
        })
            .catch(fail);
    },
};
const fail = ({ message }) => {
    console.error(message);
    process.exitCode = 2;
};
const filterResultsBySeverity = (results, failSeverity) => {
    const diagnosticSeverity = severity_1.getDiagnosticSeverity(failSeverity);
    return results.filter(r => r.severity <= diagnosticSeverity);
};
exports.severeEnoughToFail = (results, failSeverity) => {
    const diagnosticSeverity = severity_1.getDiagnosticSeverity(failSeverity);
    return results.some(r => r.severity <= diagnosticSeverity);
};
exports.default = lintCommand;
//# sourceMappingURL=lint.js.map
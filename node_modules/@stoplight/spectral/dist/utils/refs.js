"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClosestJsonPath = exports.safePointerToPath = exports.getEndRef = exports.traverseObjUntilRef = exports.isAbsoluteRef = void 0;
const json_1 = require("@stoplight/json");
const path_1 = require("@stoplight/path");
const lodash_1 = require("lodash");
const startsWithProtocol_1 = require("./startsWithProtocol");
exports.isAbsoluteRef = (ref) => path_1.isAbsolute(ref) || startsWithProtocol_1.startsWithProtocol(ref);
exports.traverseObjUntilRef = (obj, path) => {
    let piece = obj;
    for (const segment of path.slice()) {
        if (!lodash_1.isObject(piece)) {
            throw new TypeError('Segment is not a part of the object');
        }
        if (segment in piece) {
            piece = piece[segment];
        }
        else if (json_1.hasRef(piece)) {
            return piece.$ref;
        }
        else {
            throw new Error('Segment is not a part of the object');
        }
        path.shift();
    }
    if (lodash_1.isObject(piece) && json_1.hasRef(piece) && Object.keys(piece).length === 1) {
        return piece.$ref;
    }
    return null;
};
exports.getEndRef = (refMap, $ref) => {
    while ($ref in refMap) {
        $ref = refMap[$ref];
    }
    return $ref;
};
exports.safePointerToPath = (pointer) => {
    const rawPointer = json_1.extractPointerFromRef(pointer);
    return rawPointer !== null ? json_1.pointerToPath(rawPointer) : [];
};
exports.getClosestJsonPath = (data, path) => {
    const closestPath = [];
    if (!lodash_1.isObject(data))
        return closestPath;
    let piece = data;
    for (const segment of path) {
        if (!(segment in piece))
            break;
        closestPath.push(segment);
        if (!lodash_1.isObject(piece[segment]))
            break;
        piece = piece[segment];
    }
    return closestPath;
};
//# sourceMappingURL=refs.js.map
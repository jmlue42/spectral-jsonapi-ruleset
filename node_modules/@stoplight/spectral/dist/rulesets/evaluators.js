"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setFunctionContext = exports.compileExportedFunction = exports.evaluateExport = void 0;
const path_1 = require("@stoplight/path");
const lodash_1 = require("lodash");
const validation_1 = require("./validation");
function requireUnavailable() {
    throw new ReferenceError('require() is supported only in the Node.JS environment');
}
function stubRequire() {
    function req() {
        requireUnavailable();
    }
    const descriptors = {
        resolve: {
            enumerable: true,
            get: requireUnavailable,
        },
        main: {
            enumerable: true,
            get: requireUnavailable,
        },
        cache: {
            enumerable: true,
            get: requireUnavailable,
        },
        extensions: {
            enumerable: true,
            get: requireUnavailable,
        },
    };
    return Object.defineProperties(req, descriptors);
}
function proxyRequire(source) {
    const actualRequire = require;
    function req(p) {
        if (p.startsWith('.')) {
            p = path_1.join(source, '..', path_1.stripRoot(p));
        }
        else {
            p = require.resolve(p, { paths: [path_1.join(source, '..')] });
        }
        return actualRequire.call(null, p);
    }
    return Object.defineProperties(req, Object.getOwnPropertyDescriptors(actualRequire));
}
const isRequiredSupported = typeof require === 'function' &&
    typeof require.main === 'object' &&
    require.main !== null &&
    'paths' in require.main &&
    'cache' in require;
const createRequire = (source) => {
    if (!isRequiredSupported) {
        return stubRequire();
    }
    if (source === null) {
        return require;
    }
    return proxyRequire(source);
};
const createDefine = (exports) => {
    const define = (nameOrFactory, factory) => {
        if (typeof nameOrFactory === 'function') {
            exports.exports = nameOrFactory();
        }
        else if (typeof factory === 'function') {
            exports.exports = factory();
        }
        return;
    };
    Reflect.defineProperty(define, 'amd', {
        value: true,
        configurable: false,
        writable: false,
        enumerable: true,
    });
    return define;
};
const isESCJSCompatibleExport = (obj) => lodash_1.isObject(obj) && 'default' in obj;
exports.evaluateExport = (body, source, inject = {}) => {
    const req = createRequire(source);
    const mod = {
        exports: {},
        require: req,
    };
    const exports = {};
    const root = {};
    const define = createDefine(mod);
    Function('module', 'exports', 'define', 'require', ...Object.keys(inject), String(body)).call(root, mod, exports, define, req, ...Object.values(inject));
    let maybeFn;
    if (isESCJSCompatibleExport(exports)) {
        maybeFn = exports.default;
    }
    else if ('returnExports' in root) {
        maybeFn = root.returnExports;
    }
    else if (isESCJSCompatibleExport(mod.exports)) {
        maybeFn = mod.exports.default;
    }
    else {
        maybeFn = mod.exports;
    }
    if (typeof maybeFn !== 'function') {
        throw new Error('Default function export expected');
    }
    return maybeFn;
};
exports.compileExportedFunction = ({ code, name, source, schema, inject }) => {
    const exportedFn = exports.evaluateExport(code, source, inject);
    const fn = schema !== null ? validation_1.decorateIFunctionWithSchemaValidation(exportedFn, schema) : exportedFn;
    Reflect.defineProperty(fn, 'name', {
        configurable: true,
        value: name,
    });
    Object.freeze(fn);
    return fn;
};
function setFunctionContext(context, fn) {
    const boundFn = Function.prototype.bind.call(fn, Object.freeze(Object.defineProperties({}, Object.getOwnPropertyDescriptors(context))));
    Object.assign(boundFn, fn);
    return boundFn;
}
exports.setFunctionContext = setFunctionContext;
//# sourceMappingURL=evaluators.js.map
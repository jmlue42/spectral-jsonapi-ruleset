"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findFile = exports.isNPMSource = void 0;
const path = require("@stoplight/path");
const fs = require("fs");
const assets_1 = require("../assets");
const consts_1 = require("../consts");
const SPECTRAL_SRC_ROOT = path.join(__dirname, '../../dist');
function resolveSpectralVersion(pkg) {
    return consts_1.SPECTRAL_PKG_VERSION.length === 0
        ? pkg
        : pkg.replace(consts_1.SPECTRAL_PKG_NAME, `${consts_1.SPECTRAL_PKG_NAME}@${consts_1.SPECTRAL_PKG_VERSION}`);
}
function resolveFromNPM(pkg) {
    try {
        return require.resolve(pkg);
    }
    catch (_a) {
        return path.join(consts_1.NPM_PKG_ROOT, resolveSpectralVersion(pkg));
    }
}
function isNPMSource(src) {
    return src.startsWith(consts_1.NPM_PKG_ROOT) && !src.includes(`${consts_1.NPM_PKG_ROOT}${consts_1.SPECTRAL_PKG_NAME}`);
}
exports.isNPMSource = isNPMSource;
async function resolveFromFS(from, to) {
    let targetPath;
    if (SPECTRAL_SRC_ROOT.length > 0 && SPECTRAL_SRC_ROOT !== '/' && to.startsWith(consts_1.SPECTRAL_PKG_NAME)) {
        targetPath = path.join(SPECTRAL_SRC_ROOT, to.replace(consts_1.SPECTRAL_PKG_NAME, './'));
        if (await exists(targetPath)) {
            return targetPath;
        }
    }
    targetPath = path.resolve(from, to);
    if (targetPath in assets_1.STATIC_ASSETS) {
        return targetPath;
    }
    if (await exists(targetPath)) {
        return targetPath;
    }
    throw new Error('File does not exist');
}
async function findFile(from, to) {
    const mapped = assets_1.RESOLVE_ALIASES[to];
    if (mapped !== void 0) {
        to = mapped;
    }
    if (to in assets_1.STATIC_ASSETS) {
        return to;
    }
    if (path.isAbsolute(to)) {
        return to;
    }
    if (path.isURL(from) && mapped === void 0) {
        return path.join(from, to);
    }
    try {
        return await resolveFromFS(from, to);
    }
    catch (_a) {
        return resolveFromNPM(to);
    }
}
exports.findFile = findFile;
function exists(uri) {
    return new Promise(resolve => {
        fs.stat(uri, err => {
            resolve(err === null);
        });
    });
}
//# sourceMappingURL=finder.js.map
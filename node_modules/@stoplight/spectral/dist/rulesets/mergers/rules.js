"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeRules = void 0;
const types_1 = require("@stoplight/types");
const lodash_1 = require("lodash");
const severity_1 = require("../severity");
const validation_1 = require("../validation");
function mergeRules(target, source, rulesetSeverity) {
    for (const [name, rule] of Object.entries(source)) {
        if (rulesetSeverity !== undefined) {
            const severity = severity_1.getSeverityLevel(source, name, rulesetSeverity);
            if (validation_1.isValidRule(rule)) {
                markRule(rule);
                rule.severity = severity;
                processRule(target, name, rule);
            }
            else {
                processRule(target, name, typeof rule === 'boolean' ? rule : severity);
            }
        }
        else {
            processRule(target, name, rule);
        }
    }
    return target;
}
exports.mergeRules = mergeRules;
const ROOT_DESCRIPTOR = Symbol('root-descriptor');
function markRule(rule) {
    if (!(ROOT_DESCRIPTOR in rule)) {
        Object.defineProperty(rule, ROOT_DESCRIPTOR, {
            configurable: false,
            enumerable: false,
            writable: false,
            value: copyRule(rule),
        });
    }
}
function updateRootRule(root, newRule) {
    markRule(root);
    Object.assign(root[ROOT_DESCRIPTOR], copyRule(newRule === null ? root : Object.assign(root, newRule)));
}
function getRootRule(rule) {
    return rule[ROOT_DESCRIPTOR] !== undefined ? rule[ROOT_DESCRIPTOR] : null;
}
function copyRuleThen(then) {
    return Object.assign(Object.assign({}, then), ('functionOptions' in then && lodash_1.isObject(then.functionOptions) ? Object.assign({}, then.functionOptions) : null));
}
function copyRule(rule) {
    return Object.assign(Object.assign({}, rule), ('then' in rule
        ? { then: Array.isArray(rule.then) ? rule.then.map(copyRuleThen) : copyRuleThen(rule.then) }
        : null));
}
function processRule(rules, name, rule) {
    const existingRule = rules[name];
    switch (typeof rule) {
        case 'boolean':
            if (validation_1.isValidRule(existingRule)) {
                const rootRule = getRootRule(existingRule);
                if (!rule) {
                    existingRule.severity = -1;
                }
                else if (rootRule === null) {
                    existingRule.severity = severity_1.getSeverityLevel(rules, name, rule);
                    updateRootRule(existingRule, existingRule);
                }
                else if ('severity' in rootRule) {
                    existingRule.severity = rootRule.severity;
                    updateRootRule(existingRule, existingRule);
                }
                else {
                    existingRule.severity = types_1.DiagnosticSeverity.Warning;
                }
            }
            break;
        case 'string':
        case 'number':
            if (validation_1.isValidRule(existingRule)) {
                existingRule.severity = severity_1.getSeverityLevel(rules, name, rule);
            }
            break;
        case 'object':
            if (Array.isArray(rule)) {
                processRule(rules, name, rule[0]);
                if (validation_1.isValidRule(existingRule) && rule.length === 2 && rule[1] !== undefined) {
                    if ('functionOptions' in existingRule.then) {
                        existingRule.then.functionOptions = rule[1];
                    }
                    updateRootRule(existingRule, null);
                }
            }
            else if (validation_1.isValidRule(existingRule)) {
                normalizeRule(rule, existingRule.severity);
                updateRootRule(existingRule, rule);
            }
            else {
                normalizeRule(rule, severity_1.getSeverityLevel(rules, name, rule));
                markRule(rule);
                rules[name] = rule;
            }
            break;
        default:
            throw new Error('Invalid value for a rule');
    }
}
function normalizeRule(rule, severity) {
    if (rule.recommended === void 0) {
        rule.recommended = true;
    }
    if (rule.severity === void 0) {
        rule.severity = severity === void 0 ? (rule.recommended !== false ? severity_1.DEFAULT_SEVERITY_LEVEL : -1) : severity;
    }
    else {
        rule.severity = severity_1.getDiagnosticSeverity(rule.severity);
    }
}
//# sourceMappingURL=rules.js.map
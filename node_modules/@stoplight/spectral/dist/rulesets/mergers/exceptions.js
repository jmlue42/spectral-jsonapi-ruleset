"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeExceptions = exports.InvalidUriError = void 0;
const json_1 = require("@stoplight/json");
const path_1 = require("@stoplight/path");
class InvalidUriError extends Error {
    constructor(message) {
        super(message);
    }
}
exports.InvalidUriError = InvalidUriError;
const normalize = ($ref, rulesetUri) => {
    const source = json_1.extractSourceFromRef($ref);
    if (rulesetUri === void 0 && source !== null && !path_1.isAbsolute(source)) {
        throw new InvalidUriError(buildInvalidUriErrorMessage($ref, rulesetUri, 'Only absolute Uris are allowed when no base ruleset uri has been provided'));
    }
    const pointer = json_1.extractPointerFromRef($ref);
    if (source === null && pointer === null) {
        throw new InvalidUriError(`Malformed exception key (${location}). You must provide either a valid pointer or a valid source, or a source with a pointer.`);
    }
    if (pointer !== null) {
        try {
            json_1.pointerToPath(pointer);
        }
        catch (_a) {
            throw new InvalidUriError(buildInvalidUriErrorMessage($ref, rulesetUri));
        }
    }
    if (source === null) {
        return pointer;
    }
    const path = rulesetUri === undefined || path_1.isAbsolute(source) ? source : path_1.join(rulesetUri, '..', source);
    return path_1.normalize(path) + (pointer !== null && pointer !== void 0 ? pointer : '');
};
const buildErrorMessagePrefix = ($ref, rulesetUri) => {
    let prefix = '';
    if (rulesetUri !== void 0) {
        prefix += `in ruleset \`${rulesetUri}\`, `;
    }
    return prefix + `\`except\` entry (key \`${$ref}\`) is malformed. `;
};
const buildInvalidUriErrorMessage = ($ref, rulesetUri, precision) => {
    return (buildErrorMessagePrefix($ref, rulesetUri) +
        `Key \`${$ref}\` is not a valid uri${precision !== void 0 ? ` (${precision})` : ''}.`);
};
function mergeExceptions(target, source, baseUri) {
    for (const [location, sourceRules] of Object.entries(source)) {
        const normalizedLocation = normalize(location, baseUri);
        const targetRules = normalizedLocation in target ? target[normalizedLocation] : [];
        const set = new Set(targetRules);
        if (sourceRules.length === 0) {
            throw new Error(buildErrorMessagePrefix(location, baseUri) + 'An empty array of rules has been provided.');
        }
        for (const rule of sourceRules) {
            if (rule.length === 0) {
                throw new Error(buildErrorMessagePrefix(location, baseUri) + 'A rule with an empty name has been provided.');
            }
            set.add(rule);
        }
        target[normalizedLocation] = [...set].sort((a, b) => a.localeCompare(b));
    }
}
exports.mergeExceptions = mergeExceptions;
//# sourceMappingURL=exceptions.js.map
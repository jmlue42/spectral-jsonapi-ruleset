"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readRuleset = void 0;
const json_ref_resolver_1 = require("@stoplight/json-ref-resolver");
const path_1 = require("@stoplight/path");
const reader_1 = require("../fs/reader");
const http_and_file_1 = require("../resolvers/http-and-file");
const finder_1 = require("./finder");
const mergers_1 = require("./mergers");
const exceptions_1 = require("./mergers/exceptions");
const validation_1 = require("./validation");
const parsers_1 = require("../parsers");
function parseContent(content, source) {
    if (path_1.extname(source) === '.json') {
        return JSON.parse(content);
    }
    return parsers_1.parseYaml(content).data;
}
async function readRuleset(uris, opts) {
    const base = {
        rules: {},
        functions: {},
        exceptions: {},
    };
    const processedRulesets = new Set();
    const processRuleset = createRulesetProcessor(processedRulesets, new json_ref_resolver_1.Cache(), opts);
    for (const uri of Array.isArray(uris) ? new Set([...uris]) : [uris]) {
        processedRulesets.clear();
        const resolvedRuleset = await processRuleset(uri, uri);
        if (resolvedRuleset === null)
            continue;
        Object.assign(base.rules, resolvedRuleset.rules);
        Object.assign(base.functions, resolvedRuleset.functions);
        Object.assign(base.exceptions, resolvedRuleset.exceptions);
        if (resolvedRuleset.parserOptions !== void 0 && !('parserOptions' in base)) {
            base.parserOptions = resolvedRuleset.parserOptions;
        }
    }
    return base;
}
exports.readRuleset = readRuleset;
const createRulesetProcessor = (processedRulesets, uriCache, readOpts) => {
    return async function processRuleset(baseUri, uri, severity) {
        const rulesetUri = await finder_1.findFile(path_1.join(baseUri, '..'), uri);
        if (processedRulesets.has(rulesetUri)) {
            return null;
        }
        processedRulesets.add(rulesetUri);
        const content = await reader_1.readParsable(rulesetUri, {
            timeout: readOpts === null || readOpts === void 0 ? void 0 : readOpts.timeout,
            encoding: 'utf8',
            agent: readOpts === null || readOpts === void 0 ? void 0 : readOpts.agent,
        });
        if (content.trim().length === 0) {
            throw new Error('Ruleset must not empty');
        }
        const { result } = await http_and_file_1.createHttpAndFileResolver({ agent: readOpts === null || readOpts === void 0 ? void 0 : readOpts.agent }).resolve(parseContent(content, rulesetUri), {
            baseUri: rulesetUri,
            dereferenceInline: false,
            uriCache,
            async parseResolveResult(opts) {
                opts.result = parseContent(opts.result, opts.targetAuthority.pathname());
                return opts;
            },
        });
        const ruleset = validation_1.assertValidRuleset(JSON.parse(JSON.stringify(result)));
        const rules = {};
        const functions = {};
        const exceptions = {};
        const newRuleset = Object.assign({ rules,
            functions,
            exceptions }, ('parserOptions' in ruleset ? { parserOptions: ruleset.parserOptions } : null));
        const extendedRulesets = ruleset.extends;
        const rulesetFunctions = ruleset.functions;
        if (extendedRulesets !== void 0) {
            for (const extended of Array.isArray(extendedRulesets) ? extendedRulesets : [extendedRulesets]) {
                let extendedRuleset;
                let parentSeverity;
                if (Array.isArray(extended)) {
                    parentSeverity = severity === void 0 ? extended[1] : severity;
                    extendedRuleset = await processRuleset(rulesetUri, extended[0], parentSeverity);
                }
                else {
                    parentSeverity = severity === void 0 ? 'recommended' : severity;
                    extendedRuleset = await processRuleset(rulesetUri, extended, parentSeverity);
                }
                if (extendedRuleset !== null) {
                    mergers_1.mergeRules(rules, extendedRuleset.rules, parentSeverity);
                    Object.assign(functions, extendedRuleset.functions);
                    exceptions_1.mergeExceptions(exceptions, extendedRuleset.exceptions, baseUri);
                }
            }
        }
        if (ruleset.rules !== void 0) {
            mergers_1.mergeRules(rules, ruleset.rules, severity === void 0 ? 'recommended' : severity);
            if (ruleset.documentationUrl !== void 0) {
                for (const [name, rule] of Object.entries(ruleset.rules)) {
                    if (validation_1.isValidRule(rule) && rule.documentationUrl === void 0) {
                        rule.documentationUrl = `${ruleset.documentationUrl}#${name}`;
                    }
                }
            }
        }
        if (ruleset.except !== void 0) {
            exceptions_1.mergeExceptions(exceptions, ruleset.except, baseUri);
        }
        if (Array.isArray(ruleset.formats)) {
            mergers_1.mergeFormats(rules, ruleset.formats);
        }
        if (rulesetFunctions !== void 0) {
            const rulesetFunctionsBaseDir = path_1.join(rulesetUri, finder_1.isNPMSource(rulesetUri) ? '.' : '..', ruleset.functionsDir !== void 0 ? ruleset.functionsDir : 'functions');
            const resolvedFunctions = {};
            await Promise.all(rulesetFunctions.map(async (fn) => {
                const fnName = Array.isArray(fn) ? fn[0] : fn;
                const fnSchema = Array.isArray(fn) ? fn[1] : null;
                const source = await finder_1.findFile(rulesetFunctionsBaseDir, `./${fnName}.js`);
                try {
                    resolvedFunctions[fnName] = {
                        name: fnName,
                        code: await reader_1.readFile(source, {
                            timeout: readOpts === null || readOpts === void 0 ? void 0 : readOpts.timeout,
                            encoding: 'utf8',
                            agent: readOpts === null || readOpts === void 0 ? void 0 : readOpts.agent,
                        }),
                        schema: fnSchema,
                        source,
                    };
                }
                catch (ex) {
                    console.warn(`Function '${fnName}' could not be loaded: ${ex.message}`);
                }
            }));
            mergers_1.mergeFunctions(functions, resolvedFunctions, rules);
        }
        return newRuleset;
    };
};
//# sourceMappingURL=reader.js.map
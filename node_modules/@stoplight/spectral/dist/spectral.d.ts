import { Dictionary, Optional } from '@stoplight/types';
import { Document, IDocument, IParsedResult } from './document';
import { CoreFunctions } from './functions';
import { IRulesetReadOptions } from './rulesets/reader';
import { RunnerRuntime } from './runner';
import { FormatLookup, FunctionCollection, IConstructorOpts, IRuleResult, IRunOpts, ISpectralFullResult, PartialRuleCollection, RegisteredFormats, RuleCollection, RunRuleCollection } from './types';
import { IParserOptions, IRuleset, RulesetExceptionCollection } from './types/ruleset';
export * from './types';
export declare class Spectral {
    protected readonly opts?: IConstructorOpts | undefined;
    private readonly _resolver;
    private readonly agent;
    readonly functions: FunctionCollection & CoreFunctions;
    readonly rules: RunRuleCollection;
    readonly exceptions: RulesetExceptionCollection;
    readonly formats: RegisteredFormats;
    readonly parserOptions: Required<IParserOptions>;
    protected readonly runtime: RunnerRuntime;
    private readonly _computeFingerprint;
    constructor(opts?: IConstructorOpts | undefined);
    static registerStaticAssets(assets: Dictionary<string, string>): void;
    protected parseDocument(target: IParsedResult | IDocument | object | string, documentUri: Optional<string>): IDocument;
    runWithResolved(target: IParsedResult | IDocument | object | string, opts?: IRunOpts): Promise<ISpectralFullResult>;
    run(target: IParsedResult | Document | object | string, opts?: IRunOpts): Promise<IRuleResult[]>;
    setFunctions(functions: FunctionCollection): void;
    setRules(rules: RuleCollection): void;
    mergeRules(rules: PartialRuleCollection): void;
    private setExceptions;
    loadRuleset(uris: string[] | string, options?: IRulesetReadOptions): Promise<void>;
    setRuleset(ruleset: IRuleset): void;
    registerFormat(format: string, fn: FormatLookup): void;
    private _generateUnrecognizedFormatError;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentInventory = void 0;
const json_1 = require("@stoplight/json");
const json_ref_resolver_1 = require("@stoplight/json-ref-resolver");
const path_1 = require("@stoplight/path");
const lodash_1 = require("lodash");
const document_1 = require("./document");
const errorMessages_1 = require("./errorMessages");
const Parsers = require("./parsers");
const utils_1 = require("./utils");
class DocumentInventory {
    constructor(document, resolver) {
        this.document = document;
        this.resolver = resolver;
        this.diagnostics = [];
        this.parseResolveResult = async (resolveOpts) => {
            const source = resolveOpts.targetAuthority.href().replace(/\/$/, '');
            const ext = path_1.extname(source);
            const content = String(resolveOpts.result);
            const parser = ext === '.json' ? Parsers.Json : Parsers.Yaml;
            const document = new document_1.Document(content, parser, source);
            resolveOpts.result = document.data;
            if (document.diagnostics.length > 0) {
                this.diagnostics.push(...errorMessages_1.formatParserDiagnostics(document.diagnostics, document.source));
            }
            this.referencedDocuments[source] = document;
            return resolveOpts;
        };
        this.graph = null;
        this.errors = null;
        const cacheKey = resolver instanceof json_ref_resolver_1.Resolver ? resolver.uriCache : resolver;
        const cachedDocuments = DocumentInventory._cachedRemoteDocuments.get(cacheKey);
        if (cachedDocuments !== void 0) {
            this.referencedDocuments = cachedDocuments;
        }
        else {
            this.referencedDocuments = {};
            DocumentInventory._cachedRemoteDocuments.set(cacheKey, this.referencedDocuments);
        }
    }
    get source() {
        return this.document.source;
    }
    get unresolved() {
        return this.document.data;
    }
    get formats() {
        return this.document.formats;
    }
    async resolve() {
        if (!lodash_1.isObjectLike(this.document.data)) {
            this.graph = null;
            this.resolved = null;
            this.errors = null;
            return;
        }
        const resolveResult = await this.resolver.resolve(this.document.data, Object.assign(Object.assign({}, (this.document.source !== null ? { baseUri: this.document.source } : null)), { parseResolveResult: this.parseResolveResult }));
        this.graph = resolveResult.graph;
        this.resolved = resolveResult.result;
        this.errors = errorMessages_1.formatResolverErrors(this.document, resolveResult.errors);
    }
    findAssociatedItemForPath(path, resolved) {
        if (!resolved) {
            const newPath = utils_1.getClosestJsonPath(this.unresolved, path);
            return {
                document: this.document,
                path: newPath,
                missingPropertyPath: path,
            };
        }
        try {
            const newPath = utils_1.getClosestJsonPath(this.resolved, path);
            let $ref = utils_1.traverseObjUntilRef(this.unresolved, newPath);
            if ($ref === null) {
                return {
                    document: this.document,
                    path: utils_1.getClosestJsonPath(this.unresolved, path),
                    missingPropertyPath: path,
                };
            }
            const missingPropertyPath = newPath.length === 0 ? [] : path.slice(path.lastIndexOf(newPath[newPath.length - 1]) + 1);
            let { source } = this;
            while (true) {
                if (source === null || this.graph === null)
                    return null;
                $ref = utils_1.getEndRef(this.graph.getNodeData(source).refMap, $ref);
                if ($ref === null)
                    return null;
                const scopedPath = [...utils_1.safePointerToPath($ref), ...newPath];
                let resolvedDoc;
                if (json_1.isLocalRef($ref)) {
                    resolvedDoc = source === this.document.source ? this.document : this.referencedDocuments[source];
                }
                else {
                    const extractedSource = json_1.extractSourceFromRef($ref);
                    source = utils_1.isAbsoluteRef(extractedSource) ? extractedSource : path_1.resolve(source, '..', extractedSource);
                    resolvedDoc = source === this.document.source ? this.document : this.referencedDocuments[source];
                    const obj = scopedPath.length === 0 || json_1.hasRef(resolvedDoc.data) ? resolvedDoc.data : lodash_1.get(resolvedDoc.data, scopedPath);
                    if (json_1.hasRef(obj)) {
                        $ref = obj.$ref;
                        continue;
                    }
                }
                const closestPath = utils_1.getClosestJsonPath(resolvedDoc.data, scopedPath);
                return {
                    document: resolvedDoc,
                    path: closestPath,
                    missingPropertyPath: [...closestPath, ...missingPropertyPath],
                };
            }
        }
        catch (_a) {
            return null;
        }
    }
}
exports.DocumentInventory = DocumentInventory;
DocumentInventory._cachedRemoteDocuments = new WeakMap();
//# sourceMappingURL=documentInventory.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Spectral = void 0;
const tslib_1 = require("tslib");
const json_1 = require("@stoplight/json");
const json_ref_resolver_1 = require("@stoplight/json-ref-resolver");
const types_1 = require("@stoplight/types");
const lodash_1 = require("lodash");
const assets_1 = require("./assets");
const document_1 = require("./document");
const documentInventory_1 = require("./documentInventory");
const functions_1 = require("./functions");
const Parsers = require("./parsers");
const request_1 = require("./request");
const http_and_file_1 = require("./resolvers/http-and-file");
const rule_1 = require("./rule");
const rulesets_1 = require("./rulesets");
const evaluators_1 = require("./rulesets/evaluators");
const exceptions_1 = require("./rulesets/mergers/exceptions");
const runner_1 = require("./runner");
const utils_1 = require("./utils");
const generateDocumentWideResult_1 = require("./utils/generateDocumentWideResult");
const severity_1 = require("./rulesets/severity");
const consts_1 = require("./consts");
lodash_1.memoize.Cache = WeakMap;
tslib_1.__exportStar(require("./types"), exports);
class Spectral {
    constructor(opts) {
        var _a;
        this.opts = opts;
        this.functions = Object.assign({}, functions_1.functions);
        this.rules = {};
        this.exceptions = {};
        this.parserOptions = Object.assign({}, consts_1.DEFAULT_PARSER_OPTIONS);
        this._computeFingerprint = lodash_1.memoize((_a = opts === null || opts === void 0 ? void 0 : opts.computeFingerprint) !== null && _a !== void 0 ? _a : utils_1.defaultComputeResultFingerprint);
        if ((opts === null || opts === void 0 ? void 0 : opts.proxyUri) !== void 0) {
            const ProxyAgent = eval('require')('proxy-agent');
            this.agent = new ProxyAgent(opts.proxyUri);
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.resolver) !== void 0) {
            this._resolver = opts.resolver;
        }
        else {
            this._resolver =
                typeof window === 'undefined' ? http_and_file_1.createHttpAndFileResolver({ agent: this.agent }) : new json_ref_resolver_1.Resolver();
        }
        this.formats = {};
        this.runtime = new runner_1.RunnerRuntime();
        this.setFunctions(functions_1.functions);
    }
    static registerStaticAssets(assets) {
        utils_1.empty(assets_1.STATIC_ASSETS);
        Object.assign(assets_1.STATIC_ASSETS, assets);
    }
    parseDocument(target, documentUri) {
        const document = target instanceof document_1.Document
            ? target
            : document_1.isParsedResult(target)
                ? new document_1.ParsedDocument(target)
                : new document_1.Document(typeof target === 'string' ? target : json_1.stringify(target, void 0, 2), Parsers.Yaml, documentUri);
        let i = -1;
        for (const diagnostic of document.diagnostics.slice()) {
            i++;
            if (diagnostic.code !== 'parser')
                continue;
            if (diagnostic.message.startsWith('Mapping key must be a string scalar rather than')) {
                diagnostic.severity = severity_1.getDiagnosticSeverity(this.parserOptions.incompatibleValues);
            }
            else if (diagnostic.message.startsWith('Duplicate key')) {
                diagnostic.severity = severity_1.getDiagnosticSeverity(this.parserOptions.duplicateKeys);
            }
            if (diagnostic.severity === -1) {
                document.diagnostics.splice(i, 1);
                i--;
            }
        }
        return document;
    }
    async runWithResolved(target, opts = {}) {
        var _a, _b;
        const document = this.parseDocument(target, (_a = opts.resolve) === null || _a === void 0 ? void 0 : _a.documentUri);
        if (document.source === null && ((_b = opts.resolve) === null || _b === void 0 ? void 0 : _b.documentUri) !== void 0) {
            document.source = document_1.normalizeSource(opts.resolve.documentUri);
        }
        const inventory = new documentInventory_1.DocumentInventory(document, this._resolver);
        await inventory.resolve();
        const runner = new runner_1.Runner(this.runtime, inventory);
        if (document.formats === void 0) {
            const registeredFormats = Object.keys(this.formats);
            const foundFormats = registeredFormats.filter(format => { var _a; return this.formats[format](inventory.resolved, (_a = document.source) !== null && _a !== void 0 ? _a : void 0); });
            if (foundFormats.length === 0 && opts.ignoreUnknownFormat !== true) {
                document.formats = null;
                if (registeredFormats.length > 0) {
                    runner.addResult(this._generateUnrecognizedFormatError(document));
                }
            }
            else {
                document.formats = foundFormats;
            }
        }
        await runner.run({
            rules: this.rules,
            functions: this.functions,
            exceptions: this.exceptions,
        });
        const results = runner.getResults(this._computeFingerprint);
        return {
            resolved: inventory.resolved,
            results,
        };
    }
    async run(target, opts = {}) {
        return (await this.runWithResolved(target, opts)).results;
    }
    setFunctions(functions) {
        utils_1.empty(this.functions);
        const mergedFunctions = Object.assign(Object.assign({}, functions_1.functions), functions);
        for (const key of Object.keys(mergedFunctions)) {
            const context = {
                functions: this.functions,
                cache: new Map(),
            };
            this.functions[key] = evaluators_1.setFunctionContext(context, mergedFunctions[key]);
        }
    }
    setRules(rules) {
        var _a;
        utils_1.empty(this.rules);
        for (const [name, rule] of Object.entries(rules)) {
            if (((_a = this.opts) === null || _a === void 0 ? void 0 : _a.useNimma) === true || utils_1.isNimmaEnvVariableSet()) {
                try {
                    this.rules[name] = new rule_1.OptimizedRule(name, rule);
                }
                catch (_b) {
                    this.rules[name] = new rule_1.Rule(name, rule);
                }
            }
            else {
                this.rules[name] = new rule_1.Rule(name, rule);
            }
        }
    }
    mergeRules(rules) {
        for (const [name, rule] of Object.entries(rules)) {
            this.rules[name] = lodash_1.merge(this.rules[name], rule);
        }
    }
    setExceptions(exceptions) {
        const target = {};
        exceptions_1.mergeExceptions(target, exceptions);
        utils_1.empty(this.exceptions);
        Object.assign(this.exceptions, target);
    }
    async loadRuleset(uris, options) {
        this.setRuleset(await rulesets_1.readRuleset(Array.isArray(uris) ? uris : [uris], Object.assign({ agent: this.agent }, options)));
    }
    setRuleset(ruleset) {
        this.runtime.revoke();
        this.setRules(ruleset.rules);
        this.setFunctions(Object.entries(ruleset.functions).reduce((fns, [key, { code, ref, name, source, schema }]) => {
            if (code === void 0) {
                if (ref !== void 0) {
                    ({ code } = ruleset.functions[ref]);
                }
            }
            if (code === void 0) {
                return fns;
            }
            fns[key] = evaluators_1.compileExportedFunction({
                code,
                name,
                source,
                schema,
                inject: {
                    fetch: request_1.default,
                    spectral: this.runtime.spawn(),
                },
            });
            return fns;
        }, {}));
        this.setExceptions(ruleset.exceptions);
        if (ruleset.parserOptions !== void 0) {
            Object.assign(this.parserOptions, ruleset.parserOptions);
        }
    }
    registerFormat(format, fn) {
        this.formats[format] = fn;
    }
    _generateUnrecognizedFormatError(document) {
        return generateDocumentWideResult_1.generateDocumentWideResult(document, `The provided document does not match any of the registered formats [${Object.keys(this.formats).join(', ')}]`, types_1.DiagnosticSeverity.Warning, 'unrecognized-format');
    }
}
exports.Spectral = Spectral;
//# sourceMappingURL=spectral.js.map
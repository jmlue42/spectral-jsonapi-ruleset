"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runner = void 0;
const types_1 = require("@stoplight/types");
const jsonpath_plus_1 = require("jsonpath-plus");
const lodash_1 = require("lodash");
const nimma_1 = require("nimma");
const document_1 = require("../document");
const rule_1 = require("../rule");
const utils_1 = require("../utils");
const generateDocumentWideResult_1 = require("../utils/generateDocumentWideResult");
const lintNode_1 = require("./lintNode");
const utils_2 = require("./utils");
const isStdInSource = (inventory) => {
    return inventory.document.source === document_1.STDIN;
};
const generateDefinedExceptionsButStdIn = (documentInventory) => {
    return generateDocumentWideResult_1.generateDocumentWideResult(documentInventory.document, 'The ruleset contains `except` entries. However, they cannot be enforced when the input is passed through stdin.', types_1.DiagnosticSeverity.Warning, 'except-but-stdin');
};
const runRule = (context, rule, exceptRuleByLocations) => {
    const target = rule.resolved ? context.documentInventory.resolved : context.documentInventory.unresolved;
    if (!lodash_1.isObject(target)) {
        return;
    }
    for (const given of rule.given) {
        if (given === '$') {
            lintNode_1.lintNode(context, {
                path: ['$'],
                value: target,
            }, rule, exceptRuleByLocations);
        }
        else {
            jsonpath_plus_1.JSONPath({
                path: given,
                json: target,
                resultType: 'all',
                callback: (result => {
                    lintNode_1.lintNode(context, {
                        path: jsonpath_plus_1.JSONPath.toPathArray(result.path),
                        value: result.value,
                    }, rule, exceptRuleByLocations);
                }),
            });
        }
    }
};
class Runner {
    constructor(runtime, inventory) {
        var _a;
        this.runtime = runtime;
        this.inventory = inventory;
        this.results = [...this.inventory.diagnostics, ...this.document.diagnostics, ...((_a = this.inventory.errors) !== null && _a !== void 0 ? _a : [])];
    }
    get document() {
        return this.inventory.document;
    }
    addResult(result) {
        this.results.push(result);
    }
    async run(context) {
        this.runtime.emit('setup');
        const { inventory: documentInventory } = this;
        const { rules, exceptions } = context;
        const runnerContext = Object.assign(Object.assign({}, context), { documentInventory, results: this.results, promises: [] });
        const isStdIn = isStdInSource(documentInventory);
        const exceptRuleByLocations = isStdIn ? {} : utils_2.pivotExceptions(exceptions, rules);
        if (isStdIn && Object.keys(exceptions).length > 0) {
            runnerContext.results.push(generateDefinedExceptionsButStdIn(documentInventory));
        }
        const relevantRules = Object.values(rules).filter(rule => rule.enabled && rule.matchesFormat(documentInventory.formats));
        const optimizedRules = [];
        const optimizedUnresolvedRules = [];
        const unoptimizedRules = [];
        const traverseCb = (rule, node) => {
            lintNode_1.lintNode(runnerContext, node, rule, exceptRuleByLocations[rule.name]);
        };
        for (const rule of relevantRules) {
            if (!(rule instanceof rule_1.OptimizedRule)) {
                unoptimizedRules.push(rule);
                continue;
            }
            if (rule.resolved) {
                optimizedRules.push(rule);
            }
            else {
                optimizedUnresolvedRules.push(rule);
            }
            rule.hookup(traverseCb);
        }
        if (optimizedRules.length > 0) {
            nimma_1.traverse(Object(runnerContext.documentInventory.resolved), lodash_1.flatMap(optimizedRules, pickExpressions));
        }
        if (optimizedUnresolvedRules.length > 0) {
            nimma_1.traverse(Object(runnerContext.documentInventory.unresolved), lodash_1.flatMap(optimizedUnresolvedRules, pickExpressions));
        }
        for (const rule of unoptimizedRules) {
            try {
                runRule(runnerContext, rule, exceptRuleByLocations[rule.name]);
            }
            catch (ex) {
                console.error(ex);
            }
        }
        this.runtime.emit('beforeTeardown');
        try {
            if (runnerContext.promises.length > 0) {
                await Promise.all(runnerContext.promises);
            }
        }
        finally {
            this.runtime.emit('afterTeardown');
        }
    }
    getResults(computeFingerprint) {
        return utils_1.prepareResults(this.results, computeFingerprint);
    }
}
exports.Runner = Runner;
function pickExpressions({ expressions }) {
    return expressions;
}
//# sourceMappingURL=runner.js.map
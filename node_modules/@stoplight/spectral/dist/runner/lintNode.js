"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lintNode = void 0;
const lodash_1 = require("lodash");
const document_1 = require("../document");
const message_1 = require("../rulesets/message");
const severity_1 = require("../rulesets/severity");
const utils_1 = require("../utils");
const utils_2 = require("./utils");
exports.lintNode = (context, node, rule, exceptionLocations) => {
    var _a;
    const fnContext = {
        original: node.value,
        given: node.value,
        documentInventory: context.documentInventory,
        rule,
    };
    const givenPath = node.path.length > 0 && node.path[0] === '$' ? node.path.slice(1) : node.path;
    for (const then of rule.then) {
        const func = context.functions[then.function];
        if (typeof func !== 'function') {
            console.warn(`Function ${then.function} not found. Called by rule ${rule.name}.`);
            continue;
        }
        const targets = utils_2.getLintTargets(node.value, then.field);
        for (const target of targets) {
            const targetPath = target.path.length > 0 ? [...givenPath, ...target.path] : givenPath;
            let targetResults;
            try {
                targetResults = func(target.value, (_a = then.functionOptions) !== null && _a !== void 0 ? _a : null, {
                    given: givenPath,
                    target: targetPath,
                }, fnContext);
            }
            catch (ex) {
                console.warn(ex);
            }
            if (targetResults === void 0)
                continue;
            if ('then' in targetResults) {
                context.promises.push(targetResults
                    .then(results => results === void 0
                    ? void 0
                    : void processTargetResults(context, results, rule, exceptionLocations, targetPath))
                    .catch(ex => {
                    console.warn(ex.message);
                }));
            }
            else {
                processTargetResults(context, targetResults, rule, exceptionLocations, targetPath);
            }
        }
    }
};
function processTargetResults(context, results, rule, exceptionLocations, targetPath) {
    var _a, _b, _c, _d, _e;
    for (const result of results) {
        const escapedJsonPath = ((_a = result.path) !== null && _a !== void 0 ? _a : targetPath).map(utils_1.decodeSegmentFragment);
        const associatedItem = context.documentInventory.findAssociatedItemForPath(escapedJsonPath, rule.resolved !== false);
        const path = (_b = associatedItem === null || associatedItem === void 0 ? void 0 : associatedItem.path) !== null && _b !== void 0 ? _b : utils_1.getClosestJsonPath(context.documentInventory.resolved, escapedJsonPath);
        const source = associatedItem === null || associatedItem === void 0 ? void 0 : associatedItem.document.source;
        if (exceptionLocations !== void 0 && utils_2.isAKnownException(path, source, exceptionLocations)) {
            continue;
        }
        const document = (_c = associatedItem === null || associatedItem === void 0 ? void 0 : associatedItem.document) !== null && _c !== void 0 ? _c : context.documentInventory.document;
        const range = (_d = document.getRangeForJsonPath(path, true)) !== null && _d !== void 0 ? _d : document_1.Document.DEFAULT_RANGE;
        const value = path.length === 0 ? document.data : lodash_1.get(document.data, path);
        const vars = {
            property: (associatedItem === null || associatedItem === void 0 ? void 0 : associatedItem.missingPropertyPath) !== void 0 && associatedItem.missingPropertyPath.length > path.length
                ? utils_1.printPath(associatedItem.missingPropertyPath.slice(path.length - 1), utils_1.PrintStyle.Dot)
                : path.length > 0
                    ? path[path.length - 1]
                    : '',
            error: result.message,
            path: utils_1.printPath(path, utils_1.PrintStyle.EscapedPointer),
            description: rule.description,
            value,
        };
        const resultMessage = message_1.message(result.message, vars);
        vars.error = resultMessage;
        context.results.push(Object.assign(Object.assign({ code: rule.name, message: (rule.message === null ? (_e = rule.description) !== null && _e !== void 0 ? _e : resultMessage : message_1.message(rule.message, vars)).trim(), path, severity: severity_1.getDiagnosticSeverity(rule.severity) }, (source !== null ? { source } : null)), { range }));
    }
}
//# sourceMappingURL=lintNode.js.map
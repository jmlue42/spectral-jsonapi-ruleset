import { DeepReadonly, GetLocationForJsonPath, IParserResult, IRange, JsonPath, Optional } from '@stoplight/types';
import { IParser } from './parsers/types';
import { IRuleResult } from './types';
export declare const STDIN = "<STDIN>";
export interface IDocument<D = unknown> {
    readonly source: string | null;
    readonly diagnostics: ReadonlyArray<IRuleResult>;
    formats?: string[] | null;
    getRangeForJsonPath(path: JsonPath, closest?: boolean): Optional<IRange>;
    trapAccess<T extends object = object>(obj: T): T;
    data: D;
}
export declare function normalizeSource(source: undefined): null;
export declare function normalizeSource(source: string): string;
export declare function normalizeSource(source: Optional<string>): string | null;
export declare class Document<D = unknown, R extends IParserResult = IParserResult<D>> implements IDocument<D> {
    protected readonly input: string;
    protected readonly parser: IParser<R>;
    protected readonly parserResult: R;
    readonly source: string | null;
    readonly diagnostics: IRuleResult[];
    formats?: string[] | null;
    constructor(input: string, parser: IParser<R>, source?: string);
    getRangeForJsonPath(path: JsonPath, closest?: boolean): Optional<IRange>;
    trapAccess<T extends object = object>(obj: T): T;
    static get DEFAULT_RANGE(): DeepReadonly<IRange>;
    get data(): any;
}
export declare class ParsedDocument<D = unknown, R extends IParsedResult = IParsedResult> implements IDocument<D> {
    protected readonly parserResult: R;
    readonly source: string | null;
    readonly diagnostics: IRuleResult[];
    formats?: string[] | null;
    constructor(parserResult: R);
    trapAccess<T extends object = object>(obj: T): T;
    getRangeForJsonPath(path: JsonPath, closest?: boolean): Optional<IRange>;
    get data(): any;
}
export interface IParsedResult<R extends IParserResult = IParserResult<unknown, any, any, any>> {
    parsed: IParserResult;
    getLocationForJsonPath: GetLocationForJsonPath<R>;
    source?: string;
    formats?: string[];
}
export declare const isParsedResult: (obj: any) => obj is IParsedResult<IParserResult<unknown, any, any, any>>;
